#lang racket
(define (divides? a b)(= (remainder a b) 0))
(define (quick-find-divisor n test-divisor)
  (define (next n)
(cond ((= n 2) 3)
      (else (+ n 2)))
  )
  (cond ((> (square test-divisor) n) n)
        ((divides? n test-divisor) test-divisor)
        (else (quick-find-divisor n (next test-divisor)))
   ))
(define (prime? n) (= n (quick-find-divisor n 2)))
(define (square a) (* a a))
(define (gcd a b) (if (= b 0) a (gcd  b (remainder a b))))


(define (filtered-accumulate combiner null-value  a b check? next )
  (cond( (> a b) null-value)
        ((check? a)(combiner  a (filtered-accumulate combiner null-value (next a) b check? next)))
         ((filtered-accumulate combiner null-value (next a) b check? next))
  ))
     
(define (prime-plus a b)
   (define (next x) (+ x 1))
  (filtered-accumulate + 0 a b prime? next)
  )
(define (gcd-times a b)
  (define (next x) (+ x 1) )
  ;(define (gcd-check? x y) (= (gcd x y) 1))
 (filtered-accumulate * 1 a b (lambda(y) (= (gcd y b) 1 next))
  )
)
(prime-plus 1 6)

;(gcd-times 1 5)