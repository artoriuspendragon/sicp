#lang racket
(define (accumulate op initial sequence)
  (if (null? sequence) initial
      (op (car sequence) (accumulate op initial (cdr sequence)))))
;accumulate
(define (double x) (+ x x))
(define (halve x)  (/ x 2))
(define (even? x)  (= (remainder x 2)0))
(define (fast-expt-first b n a)
  (cond ((= n 0)1)
         ((= n 1)(* b a))
         ((even? n) (fast-expt-first (* b b) (/ n 2) a))
         (else (fast-expt-first b (- n 1) (* a b))
         )))
(define (fast-expt b n) (fast-expt-first b n 1))
;â†‘fast-expt function


(define (=number? exp num) (and (number? exp) (= exp num)))
(define (variable? x) (symbol? x))
(define (same-variable? x y) (and (variable? x ) (variable? y) (equal? x y )))
(define (addend s) (cadr s))
(define (augend s) (if (> (length s) 3 ) (append (list '+ )(cddr s)) (caddr s)))
(define (make-sum . s)(let ((f-s(filter (lambda (x)  (and (not (=number? x 0)) (not (null? x)))) (append (list '+) (filter (lambda (x) (not (number? x))) s)  (list (accumulate (lambda (x y) (+ (if (number? x) x 0) y)) 0 s))))))
                        (cond ((< (length f-s) 2) null)
                              ((=(length f-s) 2) (cadr f-s))
                              (else f-s))
                        ))
(define (sum? x) (and (pair? x)(equal? '+ (car x))))

(define (coutain? s number) (cond ((null? s) #f)
                                  ((=number? (car s) number) #t)
                                  (else (coutain? (cdr s) number))))
(define (make-product . s) (let ((f-s(let((n-product(accumulate (lambda (x y) (if  (number? x) (if (= x 0) 0 (* x y)) (* 1 y))) 1  s)))
                             (cond ((= n-product 0) 0)
                                   ((= n-product 1) (filter (lambda (x) (and(not (number? x))(not (null? x))) )  s))
                                   (else (append (filter (lambda (x) (and(not (number? x)) (not (null? x))) ) s) (list n-product)))))))
                             (cond ((number? f-s) f-s)
                               ((< (length f-s) 1) 0)
                              ((=(length f-s) 1) (car f-s))
                              (else (append (list '*) f-s)))))
(define (product? s) (and (equal? '* (car s)) (pair? s)))
(define (multiplier s) (cadr s))
(define (multiplicand s) (if (> (length s) 3) (apply make-product (cddr s)) (caddr s)))
(define (make-exponentiation var times) (cond ((and (number? var) (number? times)) (fast-expt var times))
                                              ((=number? times 0) 1)
                                              ((=number? times 1) var)
                                              (else (list '** var times)) ))
(define (exponentiation? s) (and (equal? '** (car s)) (pair? s)))
(define (base s) (cadr s))
(define (exponent s) (caddr s))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var) (deriv (augend exp) var)))
        ((product? exp) (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var)) (make-product (deriv (multiplier exp) var) (multiplicand exp))))
        ((exponentiation? exp) (make-product (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1))) (deriv (base exp) var)))
        (else (error exp))))
;(deriv (make-sum 'x 'y 6 't 6 4 ) 'x)
(deriv'(* x y (+ x 3)) 'x)


