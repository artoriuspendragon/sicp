#lang racket
(define(element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((< x (car set)) false)
        (else (element-of-set? x (cdr set)))))
(define (adjoin-set x set)
  (if (element-of-set? x set) set (cons x set)))
(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2)) '()
        (let ((x1 (car set1))
              (x2 (car set2)))
          (cond ((= x1 x2) (cons x1 (intersection-set (cdr x1) (cdr x2))))
                ((< x1 x2) (intersection-set (cdr x1) x2))
                ((> x1 x2) (intersection-set x1 (cdr x2)))))))
(define (union-set set1 set2)
  (cond((null? set1) set2)
      ((null? set2) set1)
      (else (let ((x (car set1)) (y (car set2)))
                (cond ((= x y)
                        (cons x (union-set (cdr set1) (cdr set2))))
                      ((< x y)
                        (cons x (union-set (cdr set1) set2)))
                      ((> x y)
                        (cons y (union-set set1 (cdr set2)))))))))
(define(adjoin x set)
  (define (adjoin-start left x right)
   (if(null? right) (append left (list x))
    (let ((first-element (car right)))
    (cond   
            ((< x first-element) (append left (list x) right ))
            ((= x first-element) (append left right))
            ((> x first-element) (adjoin-start (append left (list (car right))) x (cdr right)))))))
  (adjoin-start '() x set))
(union-set (list 3 4 5 6 7) (list 1 2 3 4 5))
